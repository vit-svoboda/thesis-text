\documentclass[11pt,oneside, final]{fithesis2}  
\usepackage[czech]{babel} % package for multilingual support  
\usepackage[utf8]{inputenc} % Windows OS encoding  
\usepackage[T1]{fontenc}  
\usepackage{lmodern}
\usepackage{cmap}

\usepackage[plainpages=false,pdfpagelabels,unicode]{hyperref}
\usepackage[numbers, sort]{natbib}
\usepackage{graphicx}
\usepackage{multirow}

%\renewcommand{\baselinestretch}{1.2}	% 1.2 radkovani

 
\thesistitle{Engine for drawing isometric game graphics in SVG} % enter thesis title  
\thesissubtitle{Diploma thesis}  
\thesisstudent{Bc. Vít Svoboda}    % name of the author  
\thesiswoman{false}          % defines author?s gender  
\thesisfaculty{fi}  
\thesisyear{podzim 2014}  
\thesisadvisor{Mgr. Marek Grác, Ph.D.} % fill in advisor?s name  
\thesislang{en}                 % thesis is in English  
 
\begin{document}  
\FrontMatter  
\ThesisTitlePage  
 
\begin{ThesisDeclaration}  
\DeclarationText  
\AdvisorName  
\end{ThesisDeclaration}  
 
\begin{ThesisThanks}  

\end{ThesisThanks}  
 
\begin{ThesisAbstract}  

\end{ThesisAbstract}  
 
\begin{ThesisKeyWords}  

\end{ThesisKeyWords}  
 
\MainMatter
 
\tableofcontents          % prints table of contents  
 
\chapter{Introduction}
Just a basic problem description.

\chapter{Theory (for the lack of a better title)}
\section{What is a graphic engine}
Graphic engine (sometimes also called rendering engine) is a software component responsible for drawing a logical model on the screen. In games this is usually a part of game engine also responsible for collision detection and physics calculation, game logic script execution etc. In desktop (=not web?) application graphic engines heavily depend on middleware like OpenGL or DirectX. 

\subsection{Typical functionality provided by an engine}
The input for a graphic engine is a set of objects on the scene and data representing their appearence (sprites, meshes and textures) and camera position. Engine has to determine what (parts of) objects are currently visible from camera's point of view and either prepare bitmap in the memory containing graphic represenation of all related objects or more often call some underlaying API to perform as described. Optionally the engine can perform various post-processing on the output, such as anti-aliasing, shading etc. More complex post-processing is usually performed only in 3D applications. When rendering a real-time video, the process has to be repeated  several times per second. The minimum to percieve smooth movement is 24 frames per second (FPS), but due to issues with synchronization of human eye and the display device, the more FPS the better. Nowadays the stadnard is 60 FPS, but military experiments showed the precision of actions in displayed video gets better up to 200 FPS [citation needed].

\section{Isometric graphics}
\subsection{Camera angle description}
\subsection{Example games, brief history}

\section{Web grahpics, HTML5}
\subsection{Canvas, usage in games}
\subsection{SVG}
Delayed adoption

Different mindset compared to standard graphic engines

\chapter{Suggested solution}
Can be used for an isometric game instead of a canvas element?

\chapter{Used technologies}
\section{Client}

\subsection{Browser support of used system javascript objects}
JSON, XmlHttpRequest

\subsection{Browser support of HTML 5 SVG element}

\subsection{SVG manipulation JavaScript libraries}

What are the options, what did I pick and why

\subsection{General utility JavaScript libraries}
For each what does it do, why do I use it, source, license
\begin{itemize}
	\item require.js
	\item jQuery
\end{itemize}

\section{Server for testing purposes}
\subsection{RESTEasy}
jBoss REST library

\subsection{Jackson}
JSON serialization

\subsection{AppEngine API}
Google App Engine hosting

\chapter{Implementation}
\subsection{Features I implemented}
\subsubsection{Sprites}
The standard (citation needed) of making 2D games is to draw small images of objects and then compose the scene using these images. This way the object can be animated easily by replacing said image with next animaiton frame image. For performance reasons all these sprites are compiled to a single image called spritesheet. The graphic engine needs to be able to draw a subselection of the image. When working with HTML5 canvas element, javascript function context.drawImage(img,sx,sy,swidth,sheight,x,y,width,height) does exactly that. First set of of coordinates and dimensions determines which part of the source image will be drawn. When using SVG, no such a straightforward and convenient way is available. To display a section of an image, one needs to create a pattern from it and position it using a negative coordinates. The pattern must use objectBoundingBox units so it doesn't shring the whole spritesheet in the target element. Then an SVG element (usually polygon) using this pattern can display desired selection of an image.
The limitation of this approach is that all elements using the same pattern must have synchronous animation, what usually doesn't look too organic in the result. On the other hand it nicely emulates the early 90s era of gaming.

\subsection{Features I did not implement with reasoning why not}

\chapter{Testing and measurement}
\subsection{Performance on desktop and mobile devices}

\chapter{Conclusion}

\bibliographystyle{csplainnat} % sets plain bibliography style  
\bibliography{sources}     % BibTeX database file  

\appendix
\chapter{How to use my engine for your game}

\end{document} 